\documentclass[10pt,a4paper,titlepage]{report}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[labelfont=bf]{caption}
\usepackage{float}
\usepackage{listings}
\usepackage[section]{placeins}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{tikz}
\usepackage{csvsimple}
\usetikzlibrary{arrows}
\usepackage[intoc, english]{nomencl}
\makenomenclature
\author{Elijah Andrews}
\title{Implementing the Discrete Element Method with OpenCL for GPUs}
\makeindex

\makeatletter
\AtBeginDocument{%
  \expandafter\renewcommand\expandafter\subsection\expandafter{%
    \expandafter\@fb@secFB\subsection
  }%
}
\makeatother

\makeatletter
\AtBeginDocument{%
  \expandafter\renewcommand\expandafter\subsubsection\expandafter{%
    \expandafter\@fb@secFB\subsubsection
  }%
}
\makeatother

\begin{document}
\tableofcontents
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
\nomenclature{$\mathbf{u}$}{Particle Velocity Vector}
\nomenclature{$\mathbf{u}_n$}{Relative Velocity Normal to Collision}
\nomenclature{$\delta$}{Particle Body Surface Overlap Distance}
\nomenclature{$\delta_{e}$}{Particle Effect Surface Overlap Distance}
\nomenclature{$\mathbf{F}$}{Force}
\nomenclature{$\mathbf{F}_n$}{Normal Contact Force}
\nomenclature{$\mathbf{F}_t$}{Tangential Contact Force}
\nomenclature{$\mathbf{F}_c$}{Cohesion Force}
\nomenclature{$\mathbf{F}_g$}{Gravitational Force}
\nomenclature{$\mathbf{F}_d$}{Drag Force}
\nomenclature{$\eta$}{Damping Coefficient}
\nomenclature{$\mathbf{\hat{n}}$}{Collision Normal Unit Vector}
\nomenclature{$\mathbf{\hat{t}}$}{Collision Tangent Unit Vector}
\nomenclature{$\mu$}{Friction Coefficient}
\nomenclature{$\zeta$}{Tangential Displacement During Interaction}
\nomenclature{$k_e$}{Normal Collision Stiffness}
\nomenclature{$k_f$}{Friction Stiffness}
\nomenclature{$k_c$}{Cohesion Stiffness}
\nomenclature{$t$}{Time}
\nomenclature{$O_p$}{Particle Origin}
\nomenclature{$s_b$}{Particle Body Surface}
\nomenclature{$s_e$}{Particle Effect Surface}
\nomenclature{$d_b$}{Particle Body Surface Diameter}
\nomenclature{$d_e$}{Particle Effect Surface Diameter}
\nomenclature{$N$}{Number of Particles}
\nomenclature{$\mathbf{u}_f$}{Fluid Velocity Vector}
\nomenclature{$\mathbf{g}$}{Gravitational Acceleration Vector}
\nomenclature{$\tau_p$}{Particle Relaxation Time}
\nomenclature{$d_p$}{Particle Diameter}
\nomenclature{$\rho_p$}{Particle Density}
\nomenclature{$\mu$}{Dynamic Viscosity}
\nomenclature{$u$}{Particle Speed}
\nomenclature{$u_{0}$}{Initial Particle Speed}
\nomenclature{$\mathbf{x}$}{Particle Position Vector}
\printnomenclature
\chapter{Introduction}
\section{Project Overview}
\textit{What the project is about, why it is significant etc.}
\section{Aims and Objectives}
The aim of this project is to observe how agglomerates form with varying simulation properties using a particle simulation developed with OpenCL. This can be separated into three main objectives:
\begin{enumerate}
\item Develop a simple particle simulation in order to understand the methodologies required for the project.
\item Develop a particle simulation that can simulate large numbers of particles ($10^7$) using OpenCL for GPUs.
\item Simulate particles in a fluid with collisions and observe how agglomerates form, including statistical analysis of agglomerate properties, as different simulation properties are varied.
\end{enumerate}
\section{Report Structure}
This report has three main parts. Firstly, the model being used and its numerical implementation are discussed. Chapter \ref{ch:The Discrete Element Method} provides detail on the mathematical model and the analytic equations of motion for the model. Chapter \ref{ch:Numerical Methods} shows how the mathematical model is implemented numerically and has some comparisons of method accuracy.
\\\\The second part explains how the model is implemented programmatically. Chapter \ref{ch:Python Implementation} discusses the initial implementation of the algorithm in Python. Chapter \ref{ch:OpenCL Implementation} contains a background in Graphics Processing Units and how OpenCL functions. It also discusses the details of the final OpenCL implementation. Both of these chapters contain relevant simulation verification test cases.
\\\\The final part is the application of the simulation to the study of how agglomerates form with varying particle properties and initial conditions. This demonstrates the capabilities of the simulation and provides some useful insights.
\section{Previous Work}
The project directly preceding this one was 'Programming GPU Cards with OpenCL to Predict the Motion of Billions of Particles'\cite{achow} by Andrew Chow. His project developed a parallelised particle-fluid simulator using OpenCL. Particle-particle interactions were not considered in his project. This project will expand upon his by implementing particle-particle interactions using the Discrete Element Method (explained in Chapter \ref{ch:The Discrete Element Method}).
\\The DEM has been implemented many times since it was originally devised by Cundall in 1971\cite{cundallphd}. Improvements in the algorithm have been proposed and implemented, and it has proven to be a reliable technique.
\\\\Many implementations have been CPU based with no parallelisation, but in recent years implementations have tended to be parallelised. The vast majority of parallel DEM implementations\cite{blazedem}\cite{GAN20161172}\cite{demcuda1}\cite{demcuda2}\cite{demcuda3} have used NVIDIA's CUDA platform which is restricted to running on NVIDIA GPUs. This means that these implementations are not usable on other hardware. One solution to this problem is to use the Open Computing Language (OpenCL). OpenCL code can be executed across heterogeneous platforms. This includes CPUs, GPUs and other, more novel, processing units. This means that an implementation programmed in OpenCL can be accessible to most users. One paper described an implementation that did use OpenCL but the application was for a real-time interactive simulation and so relatively low numbers of particles were used (16,000 was the maximum benchmarked)\cite{kinect}. Another paper briefly describes an adaptation of a simple existing implementation and its performance, however testing, decision, and implementation details are not extensive and testing was only done with $2^{17}$ (131,072) particles\cite{washizawa}.
\\This project draws from the work of Rob Tuley whose PhD thesis\cite{tuley} outlined some of the key aspects of the DEM as well as its application in powder simulations.
\chapter{The Discrete Element Method}
\label{ch:The Discrete Element Method}
The Discrete Element Method (DEM) is a numerical method for simulating how particles move and interact. The general principle is that individual particles of a medium are treated as separate rather than making continuum assumptions. This makes it a good method for modelling behaviours in granular materials such as sand, grain, or powder. 
\\\\There are two main categories of particle simulation: soft models and hard models. Soft models allow for overlap and treat collisions as sustained events whereas hard models treat collisions as an instantaneous event and model forces as an impulse. Soft collision models have broader applicability as they model sustained contact and multiple simultaneous collisions as well as some other complex phenomena\cite{softvshard}. For this reason a soft contact model is used in this project.
\section{Particle Definition}
The DEM can be used with arbitrary polyhedra, however for simplicity this project will only consider spherical particles as defined in figure \ref{fig:particle} where $O_p$ is the particle origin, $s_b$ is the body surface, and $s_e$ is the effect surface. The diameters of the particle body surface and particle effect surface are denoted by $d_b$ and $d_e$, respectively.
\begin{figure}[!ht]
\centering
\input{figures/particle.tex}
\caption{Definition of a particle.}
\label{fig:particle}
\end{figure}
\section{DEM Forces}
\label{sec:DEM Forces}
The Discrete Element Method can simulate a number of different forces using a variety of models. The merits of some of the most common models are discussed in Tuley\cite{tuley}. For this project the simplest force models have been chosen to reduce the overall complexity of the simulation.
\subsection{Normal Contact Force}
In a real elastic collision there will be some deformation of the particles. Calculating the deformation itself would be computationally expensive and would not be of interest in the study of particle population behaviours. The interaction can be modelled as a linear spring-dashpot arrangement where the overlap between the two particles is the compression of the spring. The damping is based on the relative velocity in the normal direction. The force is thus described by equation \ref{eq:normal contact force} where $k_{e}$ is the collision stiffness, $\delta$ is the particle overlap, $\mathbf{\hat{n}}$ is the unit vector normal to the collision, $\eta$ is the damping coefficient, and $\mathbf{u}_{n}$ is the normal velocity.%TODO Make this clearer.
\begin{equation}
\mathbf{F}_{n} = k_{e} \delta \mathbf{\hat{n}} - \eta \mathbf{u}_{n}
\label{eq:normal contact force}
\end{equation}
\subsection{Tangential Contact Force}
\label{sec:tangential contact force}
The tangential contact force is the friction between two particle surfaces. There are two regimes of friction force, static and dynamic. In the static regime there is no tangential motion and the friction acts to stop motion. In the dynamic regime two surfaces are sliding across one another and the friction acts to arrest this motion. The static regime usually has a higher friction coefficient than the dynamic regime. The simplest and least computationally expensive model for friction is a 'complex friction model'. This calculates values for both of the regimes and applies the minimum of the two calculations.\cite{tuley}
\\\\Tuley\cite{tuley} mentions to common static friction models, one without damping and one with damping. These are shown in Equation \ref{eq:static friction} and Equation \ref{eq:static friction with damping} where $k_f$ is the friction stiffness, $\zeta$ is the tangential displacement during the interaction, $\mathbf{\hat{t}}$ is the unit vector tangential to the collision, $\eta$ is the damping coefficient, and $\mathbf{u}_t$ is the velocity tangential to the collision. The merit of these models is discussed in section \ref{sec:friction model}.
\begin{equation}
\mathbf{F}_{t}^{static} = - k_{f} \zeta \mathbf{\hat{t}}
\label{eq:static friction}
\end{equation}
\begin{equation}
\mathbf{F}_{t}^{static} = - k_{f} \zeta \mathbf{\hat{t}} - \eta \mathbf{u}_t
\label{eq:static friction with damping}
\end{equation}
\\The dynamic regime friction force is calculated with equation \ref{eq:dynamic friction} where $\mu$ is the coefficient of friction.
\begin{equation}
\mathbf{F}_{t}^{dynamic} = - \mu |\mathbf{F}_{n}| \mathbf{\hat{t}}
\label{eq:dynamic friction}
\end{equation}
\\The final tangential friction force is defined in equation \ref{eq:friction force}.
\begin{equation}
\mathbf{F}_{t} = -\mathbf{\hat{t}}min(|\mathbf{F}_{t}^{static}|, |\mathbf{F}_{t}^{dynamic}|)
\label{eq:friction force}
\end{equation}
\subsection{Cohesion Force}
Cohesion is the attractive force between two bodies of the same material, adhesion is the attractive force between two bodies of different materials. For this project all of the particles and walls are assumed to be of the same material and so only cohesion is considered, however adhesion could be modelled using varying cohesion stiffnesses. Although there are many complex effects that could be considered\cite{tuley}, a basic linear approximation can be used to model a cohesion force. This is defined in equation \ref{eq:cohesion force} where $k_c$ is the cohesion stiffness and $\delta_e$ is the particle effect surface overlap.
\begin{equation}
\mathbf{F}_{c} = k_{c} \delta_{e} \mathbf{\hat{n}}
\label{eq:cohesion force}
\end{equation}
\section{Equations of Motion}
The motion of particles in the simulation is governed by equation \ref{eq:acceleration}. This is derived from Newton's Second Law of motion. The total force, $\mathbf{F}$ is a combination of forces as shown in equation \ref{eq:total force}. $\mathbf{F}_{n}$, $\mathbf{F}_{t}$, and $\mathbf{F}_{c}$ are the forces defined in section \ref{sec:DEM Forces}. $\mathbf{F}_{g}$ and $\mathbf{F}_{d}$ are the gravitational force and drag force, respectively, and are defined in section \ref{sec:drag and gravity}.
\begin{equation}
\dfrac{d\mathbf{x}}{dt} = \mathbf{u}
\label{eq:position}
\end{equation}
\begin{equation}
\dfrac{d\mathbf{u}}{dt} = \dfrac{\mathbf{F}}{m}
\label{eq:acceleration}
\end{equation}
\begin{equation}
\mathbf{F} = \mathbf{F}_{n} + \mathbf{F}_{t} + \mathbf{F}_{c} + \mathbf{F}_{g} + \mathbf{F}_{d}
\label{eq:total force}
\end{equation}
\subsection{Drag and Gravitational Forces}
\label{sec:drag and gravity}
Assuming low Reynolds numbers, Stokes's flow relationships can be used. This includes Stokes's drag, defined in Equation \ref{eq:drag force}, where $m$ is particle mass, $\tau_p$ is particle relaxation time, $\mathbf{u}_f$ is fluid velocity, and $\mathbf{u}$ is particle velocity. Stokes's drag applies to spheres moving through a very low Reynolds number fluid. In this situation the drag force is approximately proportional to velocity.
\begin{equation}
\label{eq:drag force}
\mathbf{F}_{d} = \dfrac{m}{\tau_p} (\mathbf{u}_f - \mathbf{u})
\end{equation}
The particle relaxation time, $\tau_p$ is an approximate timescale describing how the particle's velocity changes in a fluid due to drag. Assuming Stokes's drag on a spherical particle, $\tau_p$ can be defined by equation \ref{eq:particle relaxation time} where $\rho_p$ is the particle density, $d_p$ is the particle diameter, and $\mu$ is the dynamic viscosity of the fluid.
\begin{equation}
\label{eq:particle relaxation time}
\tau_{p} = \dfrac{\rho_{p} d^{2}_{p}}{18 \mu}
\end{equation}
The gravity force is simple and defined in equation \ref{eq:gravitational force}.
\begin{equation}
\label{eq:gravitational force}
\mathbf{F}_{g} = m \mathbf{g}
\end{equation}
\section{Useful Results}
\subsection{Reduced Mass}
When considering the motion of two particles relative to each other a useful property is the reduced mass. Consider the relative acceleration of two particles in a collision. To determine the relative acceleration between the two particles, the two accelerations must be combined. It is known that $F_1$ and $F_2$ are equal and opposite. Finding the relative acceleration results in equation \ref{eq:relative acceleration}. This provides a relationship between the force in a collision and the relative acceleration as a result of that collision. It is of a similar form as Newton's Second Law but with the usual mass replaced with the reduced mass of the two particles (equation \ref{eq:reduced mass}). This reduced mass can be used instead of particle mass in equation \ref{eq:acceleration} when considering relative motion of particles.
\begin{align}
F_1 &= m_1 a_1 \nonumber
\\F_2 &= m_2 a_2 \nonumber
\\F_1 &= -F_2 \nonumber
\\a_{rel} &= a_2 - a_1 \nonumber
\\&= \dfrac{F_2}{m_2} - \dfrac{F_1}{m_1} \nonumber
\\&= \dfrac{F_2}{m_2} + \dfrac{F_2}{m_1} \nonumber
\\&= F_2 \Big(\dfrac{1}{m_2} + \dfrac{1}{m_1}\Big) \nonumber
\\&= F_2 \Big(\dfrac{m_1 + m_2}{m_1 m_2}\Big) \nonumber
\\F_2 &= \Big(\dfrac{m_1 m_2}{m_1 + m_2}\Big) a_{rel} \label{eq:relative acceleration}
\\m_{reduced} &= \dfrac{m_1 m_2}{m_1 + m_2} \label{eq:reduced mass}
\end{align}
It should be noted that equation \ref{eq:reduced mass} reduces to $m_1$ if $m_2$ tends to infinity. This is useful when considering static particles with infinite density and is used extensively for verifying simulation results (see section \ref{sec:verification}).
\subsection{Collision Duration}
\label{sec:collision duration}
The collision duration is the time it takes for a collision to occur. This is important because if the simulation timestep is not low enough there will not be enough steps within a collision to produce accurate results. The collision duration is fully derived in section \ref{der:collision duration} and is calculated using Equation \ref{eq:collision duration}. The collision duration is often simplified to Equation \ref{eq:simplified collision duration}.
\begin{equation}
t_{col} = \sqrt{\dfrac{m}{k_e}}\sqrt{\pi^2 + ln(\epsilon)^2}
\label{eq:collision duration}
\end{equation}
\begin{equation}
t_{col} = \pi \sqrt{\dfrac{m}{k_e}}
\label{eq:simplified collision duration}
\end{equation}
\subsection{Coefficient of Restitution}
The coefficient of restitution is ratio of speed before and after a collision. For a damped collision the coefficient of restitution is between 0 and 1. The coefficient of restitution for a normal collision is fully derived in Appendix \ref{ch:Derivations} and is related to the damping coefficient, $\eta$, by equation \ref{eq:damping coefficient}. This is derived in section \ref{der:coefficient of restitution}.
\begin{equation}
\eta = - 2 ln(\epsilon) \sqrt{\dfrac{m k_e}{\pi^2 + ln(\epsilon)^2}}
\label{eq:damping coefficient}
\end{equation}
\section{Particle Rotation}
For arbitrary polyhedral particles rotation can be important since the particles will collide at different angles and it can make a significant difference to the result. With spherical particles this is less important since the collision geometry is always the same. Spherical particles can rearrange easier if rotation is considered but reasonably accurate results can still be obtained without implementing rotation. The aim of this project is to analyse how agglomerates form with a change in simulation properties so having fully accurate results is not necessary as long as the changes in behaviour can be captured.
\section{Collision Detection}
\label{sec:collision detection}
A key part of the DEM is effective collision detection. If approached naively collision detection is simply calculating the overlap for every particle with every other particle. This is extremely inefficient and causes the simulation to run in $O(N^2)$ time, where $N$ is the number of particles. To improve efficiency this process can be split into two phases. Firstly, the broad phase determines which particles could collide with which other particles. This reduces the number of particle collisions that have to be calculated. The second phase, collision resolution, resolves the collisions by measuring overlap. The goal of the broad phase is to allow the simulation to run in $O(N)$ time.
\\\\There are many different algorithms that can be used for broad phase collision detection, varying in complexity and efficiency. Although some of the more complex algorithms were considered, the gain in efficiency was not significant enough to outweigh the significant increase in implementation complexity. For this reason the simplest algorithm, spatial zoning, has been chosen for this project.
\\\\Spatial zoning separates the simulation domain into control volumes. Particles are then sorted into the control volumes. Particles in neighbouring, or the same, control volumes are then resolved fully. It is most efficient to have the control volumes as small as possible because this reduces the number of particles in neighbouring control volumes. Control volumes must be at least as large as the largest particle in the simulation to ensure that neighbouring control volumes contain all possible collisions. For monodisperse particle populations this means that the control volumes should be the same size as the particles. For polydisperse particle populations this means that the control volumes should be the size of the largest particle in the population. As mentioned in Tuley\cite{tuley} this can decrease efficiency for statistical distributions of particle sizes. Sections \ref{sec:Python Collision Detection} and \ref{sec:OpenCL Collision Detection} provide further detail as to how this is implemented computationally in Python and with OpenCL, respectively.
\\\\$<$\textit{Algorithm flowchart will go here.}$>$
\chapter{Numerical Methods}
\label{ch:Numerical Methods}
\section{Numerical Integration Schemes}
The DEM model used in this project has stiff governing equations. This means that the simulation may become unstable if the timestep is not sufficiently small. Thus, the choice of integration scheme is important. For simplicity, there are three main schemes that will be considered for this project: the Euler method (or forward Euler method), the backward Euler method (or implicit Euler method), and the trapezoidal rule.
\\\\The forward Euler method is an explicit integration method, using the current value to estimate the next value. It has first order accuracy and requires only the data from the current iteration.
\\\\The backward Euler method is an implicit integration method, assuming the next value and solving the equation for it. It also has first order accuracy and requires only the data from the current iteration.
\\\\The trapezoidal rule is an implicit integration method that uses the average of the current and next values. It has second order accuracy.
\\\\For the implicit methods either an analytic solution to the implicit equations or a numerical solution can be used. For simplicity, only the functions that can form analytic solutions from the implicit equations will use the implicit methods.
\subsection{Velocity}
For equation \ref{eq:acceleration} the forward Euler method for integrating acceleration to get velocity at iteration $n + 1$ is shown in equation \ref{eq:Forward Euler Acceleration}. In this case the force, $F$, is a function of $u_n$.
\begin{equation}
u_{n+1} = u_{n} + \dfrac{F(u_n)}{m}\Delta t
\label{eq:Forward Euler Acceleration}
\end{equation}
\\For the same equation, the backward Euler method is shown in equation \ref{eq:Backward Euler Acceleration}. In this case the force, $F$, is a function of $u_{n+1}$.
\begin{equation}
u_{n+1} = u_{n} + \dfrac{F(u_{n+1})}{m}\Delta t
\label{eq:Backward Euler Acceleration}
\end{equation}
For the DEM the total force is a combination of forces (see equation \ref{eq:total force}). Drag and gravity forces are only calculated once per iteration and so can be calculated at the same time as the velocity. However, collision forces are calculated multiple times per iteration to get contributions from all collisions and so cannot be easily calculated at the same time as the velocity. For this reason, the normal force, tangential force, and cohesion force are treated as fixed at the time of velocity calculation. Gravity is also fixed and so equation \ref{eq:total force} can be represented as in equations \ref{eq:force at iteration} and \ref{eq:fixed force plus}. $F(u)$ can then be used in equation \ref{eq:Forward Euler Acceleration} or \ref{eq:Backward Euler Acceleration}.
\begin{align}
F(u) &= F_n + F_t + F_c + F_g + F_d(u)
\label{eq:force at iteration} \\
F_{fixed} &= F_n + F_t + F_c + F_g \\
F(u) &= F_{fixed} + F_d(u) \label{eq:fixed force plus}
\end{align}
For equation \ref{eq:Forward Euler Acceleration} it is trivial to calculate the next velocity as the RHS is only dependant on $u_n$ which is known. This results in equation \ref{eq:explicit next velocity}.
\begin{equation}
u_{n+1} = u_n + \dfrac{F_{fixed} + F_d(u_n)}{m} \Delta t \label{eq:explicit next velocity}
\end{equation}
Equation \ref{eq:Backward Euler Acceleration} must be rearranged to get $u_{n+1}$ as a function of $u_{n}$ only. This results in equation \ref{eq:implicit next velocity}.
\begin{align}
F(u_{n+1}) &= F_{fixed} + \dfrac{m}{\tau_p}(u_f - u_{n+1}) \nonumber \\
u_{n+1} &= u_n + \dfrac{F_{fixed} + \dfrac{m}{\tau_p}(u_f - u_{n+1})}{m}\Delta t \nonumber \\
&= u_n + \dfrac{F_{fixed}}{m}\Delta t + \dfrac{\Delta t}{\tau}(u_f - u_{n+1}) \nonumber \\
u_{n+1} (1 + \dfrac{\Delta t}{\tau}) &= u_n + \dfrac{F_{fixed}}{m}\Delta t + \dfrac{\Delta t}{\tau}(u_f) \nonumber \\
u_{n+1} &= \dfrac{\tau u_n + F_{fixed} \tau \Delta t / m + u_f \Delta t}{\tau + \Delta t} \label{eq:implicit next velocity}
\end{align}
Equation \ref{eq:implicit next velocity} can be rearranged to be in the same form as equation \ref{eq:explicit next velocity} as shown in equation \ref{eq:rearranged implicit next velocity}.
\begin{equation}
u_{n+1} = u_n + \Big(\dfrac{u_f - u_n + \tau F_{fixed} / m}{\tau + \Delta t}\Big)\Delta t
\label{eq:rearranged implicit next velocity}
\end{equation}
A comparison of the accuracy of these integration schemes is in section \ref{sec:integration scheme comparison}.
\subsection{Position}
Equation \ref{eq:position} is a very simple differential equation that can be solved by integrating. Since the velocity does not directly depend on the position, and the velocity for the next iteration is calculated before the position, it is trivial to use the trapezoidal rule to calculate position. It has all of the advantages of accuracy without the disadvantage of increased complexity. The position can thus be calculated with equation \ref{eq:iterative position}.
\begin{equation}
x_{n+1} = x_n + \dfrac{u_n + u_{n+1}}{2}\Delta t
\label{eq:iterative position}
\end{equation}
\subsection{Comparison of Integration Schemes}
\label{sec:integration scheme comparison}
This analysis was performed using the Python implementation discussed in Chapter \ref{ch:Python Implementation}.
\\Figure \ref{fig:terminal_velocity_implicit_explicit} shows the speed of a particle in a fluid starting from rest and accelerating to the fluid velocity. It shows that the explicit velocity equation (equation \ref{eq:explicit next velocity}) over-estimates the speed and the implicit velocity equation (equation \ref{eq:implicit next velocity}) under-estimates the speed. The error in the implicit result is less than the error in the explicit result.
\\\\Figure \ref{fig:avg_percent_diff_against_timestep} shows the average percentage difference between each numerical method and the analytic solution for varying timestep. This shows that the explicit method is exactly first order accurate whereas the implicit result is a bit higher than first order accurate. This means that it is better to use the implicit method than the explicit method.
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.6]{figures/TerminalVelocityImplicitExplicit.png}
\caption{Particle speed against time with different integration schemes.}
\label{fig:terminal_velocity_implicit_explicit}
\end{figure}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.6]{figures/AveragePercentageDifferenceAgainstTimestep.png}
\caption{Average percentage difference between the numerical method and analytical solution against varying timestep. The jaggedness of the lines is due to the discrete changes in timestep causing small rounding errors.}
\label{fig:avg_percent_diff_against_timestep}
\end{figure}
\section{Friction Model}
\label{sec:friction model}
The static friction models outlined in Section \ref{sec:tangential contact force} both rely on the tangential displacement during an interaction, $\zeta$. This is a difficult property to determine as it requires a collision history to be maintained for it to be correctly measured. Maintaining a collision history adds significant complication to a simulation as it requires data to be stored between timesteps an for collisions in each timestep to be related to one another. As this implementation of the DEM ignores rotation, the accuracy of the simulation when considering sliding is limited. Increasing the simulation complexity in order to slightly improve the friction model is not necessary so various alternatives have been considered. The graphs presented below use the friction verification case from Section \ref{sec:friction sliding verification}.
\subsection{Dynamic Friction Only}
Removing the static friction part of the model entirely is tempting, it would simplify the calculation and make the code slightly faster. However, the dynamic friction model is prone to instability, especially at high timesteps, the particle ends up oscillating around a point because the model does not handle overshoot well. This behaviour is shown in Figure \ref{fig:dynamic_only}.
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.65]{figures/friction_model/dynamic_only.png}
\caption{Position and velocity against time for a dynamic only friction model. Note high levels of instability, especially in the velocity.}
\label{fig:dynamic_only}
\end{figure}
\subsection{Static Friction Without Damping}
Two methods were considered for calculating the tangential displacement, $\zeta$. The first was to simply estimate how far the particle moved in a timestep by multiplying the tangential velocity by the timestep. This method does not work because as the timestep decreases the static friction decreases and the error increases. This effect is demonstrated in Figure \ref{fig:delta_t_static}.
\\\\The alternative method was to estimate $\zeta$ by multiplying the tangential velocity by a the collision duration (see Section \ref{sec:collision duration}). The results for this model are shown in Figure \ref{fig:t_col_static}. This provides far more accurate results and solves both the instability problem from the dynamic model and the underestimation problem from the timestep based static friction model.
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.5]{figures/friction_model/delta_t_static.png}
\caption{Position and velocity against time for a timestep based static model. Note the increasing error with decreasing timestep.}
\label{fig:delta_t_static}
\end{figure}
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.5]{figures/friction_model/t_col_static.png}
\caption{Position and velocity against time for a collision duration based static model.}
\label{fig:t_col_static}
\end{figure}
\subsection{Static Friction With Damping}
The static friction model with damping from Equation \ref{eq:static friction with damping} was investigated but did not provide any significant improvement in accuracy or stability over the static model without damping.
\section{Verification}
A series of verification test cases have been developed in order to assess the accuracy of the numerical model in the program implementations. The definitions and equations for these models are in this section and the implementation comparisons are in Sections \ref{sec:Python verification} and \ref{sec:OpenCL verification}.
\label{sec:verification}
\subsection{Drag}
The drag verification case is a particle in a fluid. The fluid has a constant velocity in the x direction denoted $u_f$. There is no gravity and no other particles are present. The particle accelerates to the speed of the fluid.
\\The position and velocity of the particle are determined by equations \ref{eq:drag position} and \ref{eq:drag velocity}, respectively. These equations are derived in section \ref{der:drag}.
\begin{align}
&x = u_f \tau (e^{-t/\tau} - 1) + u_f t \label{eq:drag position} \\
&\dot{x} = u_f (1 - e^{-t/\tau}) \label{eq:drag velocity} \\
\end{align}
\subsection{Normal Collision}
\label{sec:normal collision verification}
The normal collision verification case is the most simple normal collision. The first particle (p1) has infinite density and so is fixed in space. The second particle (p2) has an initial velocity, $u_0$, towards the first particle and starts at $x = d_b$ so that the body surfaces are just touching. There is no drag, no gravity, and no cohesion. This arrangement is depicted in Figure \ref{fig:normal collision}.
\\The position and velocity of the second particle are determined by equations \ref{eq:normal collision position} and \ref{eq:normal collision velocity}, respectively. These equations are derived in section \ref{der:normal collision}.
\begin{align}
&x = e^{at} \dfrac{u_0}{b} sin(bt) + d_b \label{eq:normal collision position} \\
&\dot{x} = u_0 e^{at} (\dfrac{a}{b} sin(bt) + cos(bt)) \label{eq:normal collision velocity}
\end{align}
\begin{figure}[!ht]
\centering
\input{figures/normal_collision.tex}
\caption{The initial setup of the normal collision verification case.}
\label{fig:normal collision}
\end{figure}
\subsection{Friction Sliding}
\label{sec:friction sliding verification}
The friction sliding test case is a particle sliding along a wall. The particle is started at the theoretical height at which the normal force balances the gravitational force. This ensures that the friction force is as stable as possible and not affected by changing normal force. The particle also has an initial velocity. This arrangement is depicted in Figure \ref{fig:friction sliding}.
The analytic solution to this case uses the dynamic friction only but is sufficient to assess the accuracy of the model. The position and velocity of the particle are determined by equations \ref{eq:friction sliding position} and \ref{eq:friction sliding velocity}, respectively.
\begin{align}
&\dot{x} = - \mu g t + u_0 \label{eq:friction sliding velocity} \\
&x = \dfrac{- \mu g}{2}t^2 + u_0 t + x_0 \label{eq:friction sliding position}
\end{align}
\begin{figure}[!ht]
\centering
\input{figures/sliding.tex}
\caption{The initial setup of the friction sliding verification case.}
\label{fig:friction sliding}
\end{figure}
\subsection{Normal Collision with Cohesion}
The cohesion collision verification case is very similar to the normal collision verification case (section \ref{sec:normal collision verification}). The first particle (p1) has infinite density and so is fixed in space. The second particle (p2) has an initial velocity, $u_0$, towards the first particle and starts at $x = d_e$ so that the effect surfaces are just touching. There is no drag and no gravity. This arrangement is depicted in Figure \ref{fig:cohesion collision}.
\\The position and velocity of the second particle are determined by the set of equations below. These equations are derived in section \ref{der:normal collision with cohesion}.
\begin{align}
&\text{When $d_e > x > d_b, u < 0$:} \nonumber \\
&x = u_0 \sqrt{\dfrac{m}{k_c}} sinh\Big(t\sqrt{\dfrac{k_c}{m}}\Big) + d_e \\
&\dot{x} = u_0 cos h\Big(t\sqrt{\dfrac{k_c}{m}}\Big) \\ \nonumber \\
&\text{When $x < d_b$:} \nonumber \\
&x = e^{at} (\dfrac{u_i - ac}{b} sin(bt) + c cos (bt)) + \dfrac{k_e d_b - k_c d_e}{k_e - k_c} \\
&\dot{x} = e^{at}\Big(\Big(\dfrac{u_i - ac}{b} a - c b\Big)sin(bt) + u_i cos(bt)\Big) \\ \nonumber \\
&\text{When $d_e > x > d_b, u > 0$:} \nonumber \\
&x = (d_b - d_e)cosh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r \sqrt{\dfrac{m}{k_c}} sinh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) + d_e \\
&\dot{x} = \sqrt{\dfrac{k_c}{m}}(d_b - d_e)sinh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r cosh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) + d_e \\ \nonumber \\
&\text{Where: } a = \dfrac{-\eta}{2m} \text{,    } b = \dfrac{\sqrt{4mk_e - \eta ^ 2}}{2m} \text{,    } c = \dfrac{k_c (d_e - d_b)}{k_e - k_c} \nonumber
\end{align}
\begin{figure}[!ht]
\centering
\input{figures/cohesion_collision.tex}
\caption{The initial setup of the cohesion collision verification case.}
\label{fig:cohesion collision}
\end{figure}
\chapter{Python Implementation}
\label{ch:Python Implementation}
\section{Overview}
An initial implementation of the Discrete Element Method has been done in Python. The objective of this implementation is to gain an understanding of the DEM and any inherent computational difficulties. Python has been chosen as a testing environment for its simplicity and ease of development. The code for the Python implementation can be found in the DEMApples GitHub repository\cite{DEMApples}.
\section{Program Structure}
\subsection{Element Types}
Different element types are required for different types of geometry and particle. For the Python implementation the two simplest have been chosen, a spherical particle and an axis-aligned wall. Python allows for object oriented programming which makes keeping track of everything very easy. Objects have been used extensively throughout the Python implementation.
\subsubsection{Particle}
The basic particle element is a spherical particle with pre-determined properties. All of these properties can be set upon instantiation of each particle object and so can be easily modified for a variety of different simulations.
\\There are two objects for particles, the main object, 'Particle', tracks a full particle state history which is very memory intensive and unnecessary for most applications. The second object, 'LowMemParticle', inherits from 'Particle' and only keeps track of the current state and, during iteration, one future state.
\\The particle is iterated using the function call 'Particle.iterate()'. This passes a $\Delta t$ to the particle object and iterates the velocity and position. The iterative functions used are discussed in Chapter \ref{ch:Numerical Methods}.
\subsubsection{Axis-Aligned Simple Wall}
The basic wall element is an axis-aligned simple wall. This object is defined by two points, minimum and maximum, that must lie in the same plane. From them a rectangle is formed. A normal is calculated for the wall and stored in the object to save time in collision calculations. The wall is treated as fixed, eliminating the need for complex material properties or calculation of motion. An axis-aligned wall has been chosen because it eliminates a lot of the complex calculations required when calculating arbitrary planar geometry. Non-axis-aligned geometry, such as a slope, can still be used in simulations by having gravity act along different vectors. This has been used in `gravity\_shift\_closed\_box.py' simulation.
\subsection{Collisions}
\subsubsection{Collision Detection}
\label{sec:Python Collision Detection}
Broad phase collision detection uses the simple spatial zoning technique from section \ref{sec:collision detection}. This approach has been chosen because it is quick and simple to implement. Other options (such as triangulation\cite{dynamictriangulations}) were considered for this implementation but the benefits of using them were far outweighed by their complexity. Since the initial Python implementation will not be fast anyway it was not deemed necessary to implement optimised algorithms at this stage.
\\\\The domain is represented by a three dimensional array where each entry is a control volume. The control volume is a list of particles in its bounds. The global list of particles is iterated over and each particle assigns itself to the correct control volume. This results in a three dimensional array where each control volume has all of the particles within its bounds as an array. Collision objects are then created for each pair of particles in the same, or neighbouring, control volumes. This approach reduces the problem from $O(N^{2})$ to almost $O(N)$ as shown in figure \ref{fig:run_time_against_N_python}.
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.75]{figures/RunTimeAgainstNumberOfParticlesPython.png}
\caption{This graph shows that the simple spatial zoning technique reduces the problem from $O(N^{2})$ down to almost $O(N)$.}
\label{fig:run_time_against_N_python}
\end{figure}
\subsubsection{Collision Resolution}
After an array of collisions has been generated they are iterated over and each collision is resolved. First, the distance between particles is calculated to determine if they are in contact. Often this reveals that they are not in contact and the calculation ends there. If particles are in contact then collision forces are determined.
\\In the Python implementation only the simple normal and tangential contact forces are calculated. These are enough to run sufficient initial test cases.
\subsection{Calculating Forces}
The mathematics for how the forces are calculated can be found in Section \ref{ch:Numerical Methods}. This section discusses some of the implementation details.
\subsubsection{Drag}
To determine drag a flow velocity must be calculated. In this implementation it is calculated using a function that is passed into the Particle object upon instantiation. This allows a variety of flow field functions to be used without modifying the Particle object code. The default for this function is a perfectly stationary flow.
\subsubsection{Gravity}
A gravity function can also be passed into the Particle object upon instantiation. Although this defaults to a simple -9.81$ms^{-2}$ in the negative z direction, it can be chosen to simulate a rotating frame of reference or other complex configurations. A rotating frame of reference has been implemented in the `gravity\_shift\_closed\_box' example simulation\cite{DEMApples}.
\subsubsection{DEM Forces}
The DEM forces that are calculated in collisions are stored in an array within the Particle object. When the particle is iterated the array is summed and used in the iteration calculation. After this calculation the array is cleared so that forces do not get incorrectly added multiple times. This configuration makes it simple to add and remove forces to the simulation whenever necessary and could also be used in general to add any force to the particle.
\section{Optimization and Performance}
\label{sec:Python verification}
\section{Verification}
\subsection{Drag}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/opencl_verification/drag_verification.png}
\caption{Normalized position and speed against time of a particle in a moving fluid.}
\label{fig:python_drag_verification}
\end{figure}
\subsection{Normal Collision}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/python_verification/normal_force_verification.png}
\caption{Normalized position and speed against time during a normal collision.}
\label{fig:python_normal_force_verification}
\end{figure}
\subsection{Friction Sliding}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.4]{figures/python_verification/friction_verification.png}
\includegraphics[scale=0.4]{figures/python_verification/friction_verification_zoomed.png}
\caption{Normalized position and speed against time during a normal collision.}
\label{fig:python_friction_verification}
\end{figure}
\chapter{OpenCL Implementation}
\label{ch:OpenCL Implementation}
\section{OpenCL and Graphics Processing Units}
The main computational device in a computer is the Central Processing Unit (CPU). The CPU takes a series of instructions and calculates pretty much anything that a computer requires. For most applications this is ideal as they require a sequence of different instructions to be executed to achieve their goal. However, for some applications this is inefficient. The most common occurrence of this is in graphics. Graphics requires the same calculations to be performed a very large number of times to render images. To run this on a CPU would take a long time because it would all run in sequence. To speed up this process Graphics Processing Units (GPUs) were developed. GPUs run the same operation many times in parallel rather than different operations in series. Individual GPU computation cores are slower than CPU cores but for graphics this is fine as the gains from running everything in parallel are massive.
\\\\Originally this was applied to graphics but more recently has been used to do scientific calculations where the same operation is repeated across a lot of data. In order to facilitate this languages have been developed to allow a developer to easily run calculations on GPUs. The two most common such languages are CUDA and OpenCL. CUDA is NVIDIA's language that is specifically designed for NVIDIA GPUs. OpenCL is an open standard maintained by the Khronos group, a consortium of companies dedicated to open standard graphics and parallel computing interfaces. OpenCL allows a developer to write programs for a variety of devices (e.g. GPUs, CPUs, and FPGAs) without having to modify the code.
\\\\There are two main parts of an OpenCL program, the host code and the device code. The host is whatever computer system is being used, usually a CPU, some memory, a storage device, and other standard elements. The device is whatever processing unit is being used to run the main calculations. Often the device would be a GPU or other, more novel, processing units. The host runs setup, memory handling, and other miscellaneous processing tasks. The device is then passed kernels to run on a group of data.
\section{Overview}
The main DEM implementation used in this project uses OpenCL to run on a GPU. The host code is written in C to simplify writing code for both the host and the device. More features are available in C++, however only OpenCL 2.1 has C++ kernel support and NVIDIA only supports up to OpenCL 1.2. Since one goal of using OpenCL is to allow the code to be used on multiple platforms, it does not make sense to use OpenCL 2.1.
\\A lot of the OpenCL utility functions used in this implementation are based on code from the previous project\cite{achow}. These functions allow for easy implementation of code without having to repeat long OpenCL function calls.
\\The code for the OpenCL implementation can be found in the DEMOranges GitHub repository\cite{DEMOranges}.
\section{Program Structure}
\subsection{Data Structures}
Unlike Python, C does not support objects. This means that more care must be taken in data storage. The most sensible way to store data is in structures. In this implementation structures are used as the primary storage method. There are three types of structures used: particle, wall, collision.
\subsubsection{Particle}
The particle structure contains particle properties (density, diameter, position, velocity etc.) as well as the fluid viscosity to make it easier to access in calculations.
\\The structure is aligned to the nearest 128 bytes of memory to make access to it faster. This does waste a little under half of this memory but for $10^7$ particles the particle array requires a total of 1.2GB which is within workable limits. Benchmarks could be performed to determine whether this trade-off is necessary, but the downside is small and so has not been considered significant. Another benefit of this alignment is that additional particle data can be stored within the particle array without costing any more memory than is already used.
\subsubsection{Wall}
The `aa\_wall' structure simply contains the minimum, maximum, and normal vector for an axis aligned wall. This structure is not aligned to the nearest 128 bytes of memory.
\subsubsection{Collision}
There are two collision structures: `pp\_collision' for particle-particle collisions and `pw\_collision' for particle-wall collisions. The structures only contain the two relevant IDs. The collision structures are not aligned to the nearest 128 bytes of memory as this would waste almost all of the memory and there can be many collisions.
\\The only notable difference between the particle-particle collision structure and the particle-wall collision structure is that the particle-particle collision structure contains data that tracks whether a collision is across a periodic boundary.
\subsubsection{Buffers}
To access the data from the device it must be passed into a buffer. None of the structure data is passed into the buffer so the device must have a copy of the definition of the structure. This is problematic as the host and device have different compilers. To work around this problem the host and device structures are written with members in descending order of size. This encourages the compiler to order them correctly.
\\In addition, when using the MSVC compiler, padding must be added to ensure correct alignment. This padding is not required when using gcc compilers. 
\\The alignment attribute specifier is also not the same between different compilers so ``if defined'' statements are implemented for both MSVC and gcc compilers to allow the code to be compiled on either without modification.
\subsection{Kernels}
The main calculations for this implementation are performed on the device. This means that the program must be separated into kernels to be passed over sets of data. There are three main sets of kernels: collision detection, collision resolution, and particle iteration.
\subsubsection{Collision Detection}
\label{sec:OpenCL Collision Detection}
To improve efficiency, in both speed and resource usage, performing naive collision detection is not viable for large numbers of particles. To improve on this the spatial zoning technique is used similar to the initial Python implementation. However, C does not make arrays of varying sizes easy or efficient so the data structures used and the algorithm implementation must be significantly different.
\\\\The basic problem is how to store control volumes as lists of references to particles. In Python this was easy, a simple 3D array of control volumes with lists of particle objects inside was sufficient. Various approaches to solving this problem were considered. One approach was to encode particle IDs (equal to the index of a particle in the particles array) with a hashing function into a single number that could be turned back into particle IDs on the device. However, this approach was infeasible because the numbers would get so large that they could not be stored accurately or efficiently.
\\\\The approach used is to have multiple passes of assignment of particles to control volumes. The first pass simply counts how many particles are in each control volume. This is stored in a one dimensional array of control volumes represented by integers of how many particles each contains. From this array another array is created. This array is of all the particle IDs but sorted into control volumes. The control volumes are of lengths defined by the count array and start at indexes stored in a third array. If a control volume has no particles, the start index of the array is set to -1. For the unsigned long data type this overflows to the maximum value (approximately 4.3 billion) which will likely never be used to index particles. This arrangement of arrays is shown in figure \ref{fig:cv_array_structure}.
\\\\This approach is somewhat similar to how memory is handled on a computer, but using indexes instead of pointers. For an entirely host-side method an array of pointers to arrays of particles could be used, but this would not be sensible when dealing with device memory as each array would need to be moved to the device before use. Having three arrays that hold all the necessary properties simplifies the memory buffer process significantly. The maths required for turning positions and control volume coordinates into indexes in these arrays are contained in cvUtils.c and kernelUtils.cl for host and device, respectively.
\begin{figure}[!ht]
\centering
\input{figures/cvarrays.tex}
\caption{Diagram showing the structure and relationship between arrays representing Control Volumes.}
\label{fig:cv_array_structure}
\end{figure}
\\One weakness of this approach is that the CV start index array is generated sequentially. A solution to this weakness could be to have each control volume add up the number of particles in all preceding control volumes in order to determine its own start index in the sorted particle array. However, this would repeat a lot of maths and could end up being slower. The function consists of adding to the start index count and then assigning the count to memory in the CV start index array. If it were to be done in parallel, the adding would have to be repeated for each CV but the memory assignment would be done in parallel. Thus, whether it would be faster sequentially or in parallel depends on which operation is slower. Although interesting, this not a significant performance problem and so has been left as it is.

\subsubsection{Collision Resolution}
\label{sec:Collision Resolution}
The collision resolution kernel is actually separated into multiple kernels for different types of collision (particle-particle and particle-wall) however the behaviour of these kernels is almost identical. For this discussion we will use the particle-particle kernel as an example. The kernel takes a pointer to an array of collision structures and a pointer to the array of particles. The DEM collision force calculations are run for each collision and the forces are added to the DEM forces vector in the relevant particle structures. This approach has been chosen because it is easier to sum the forces as they are calculated rather than attempt to predict the length of the necessary force array to store each force separately as in the Python implementation.
\\\\This approach causes a serious problem as it is possible that multiple collision kernels will need to write data to the same particle at the same time. The solution to this is to use the atomic operations available in OpenCL. Unfortunately, OpenCL only natively supports full atomic operations for int and unsigned int data types. OpenCL does support an exchange atomic operator for single precision floats, but this is not the best approach for doing atomic arithmetic for floats.
\\\\An approach for doing atomic addition (as is necessary in this case) is recommended in an online article\cite{atomic_addition}.
The code is shown in figure \ref{fig:atomic_float_addition}. This approach uses the comparison exchange atomic operator by creating a union of the floats with unsigned ints. This works well because the bits being exchanged are the same for the float and unsigned int and actual atomic arithmetic is not necessary so the difference between the data types does not matter. Thus the new value is calculated and if the value used to calculate it has changed in that time the calculation is repeated with the updated value.
\begin{figure}[!ht]
\begin{lstlisting}[language=C]
 _INLINE_ void atomicAdd_g_f(volatile __global float *addr, float val)
   {
       union{
           unsigned int u32;
           float        f32;
       } next, expected, current;
   	current.f32    = *addr;
       do{
   	   expected.f32 = current.f32;
           next.f32     = expected.f32 + val;
   		current.u32  = atomic_cmpxchg( (volatile __global unsigned int *)addr, 
                               expected.u32, next.u32);
       } while( current.u32 != expected.u32 );
   }
\end{lstlisting}
\caption{Kernel code for a solution to atomic addition with floats.}
\label{fig:atomic_float_addition}
\end{figure}
\subsubsection{Particle Iteration}
Particle iteration is performed almost identically to the Python implementation. The main difference, as discussed in section \ref{sec:Collision Resolution}, is that the OpenCL implementation performs the summation of DEM forces as they are calculated in collisions whereas the Python implementation performs the summation when iterating the particle.
\subsection{Unit Tests}
Due to the large size of the project and algorithmic complexity, it is important to test each unit of code individually rather than trying to trace bugs through the whole code-base. In addition, this project is intended to be run on heterogeneous devices and so differences in runtime environment could cause problems. For these reasons a unit testing approach has been chosen so that tests can be quickly re-run to check code unit functionality without assuming identical behaviour between systems.
\\Some functions are not included in the unit testing system due to their simplicity and the relatively long time it would take to program unit tests for all of them. For example, checking that a function multiplies numbers correctly does not need to be tested every time.
\subsubsection{Testing Framework}
Often a framework is used for unit testing, however there is not a quick, easy framework available for C with OpenCL so a simple system has been set up to make running tests easy.
\\Each tested feature has a directory within the 'tests' directory with its header and C code files. A feature may have multiple functions, each with its own testing function. Each testing function takes a boolean parameter, 'verbose', that determines whether it prints intermediate results and debugging outputs. The functions return a boolean that indicates whether the test passed or not. In some cases, if a function fails, it may not be obvious why and so debugging outputs will be printed. For example, test\_assign\_particle\_count could have the wrong number of control volumes or incorrectly assigned particles so both of these outcomes has its own printed debugging output. %TODO Reference code
\\To make it easy to run these tests repeatedly 'run\_tests.c' has been created to run all of the tests and indicate which, if any, fails. A similar implementation is executed at simulation runtime to ensure that all tests are passed before starting a simulation run.
\section{Verification}
\label{sec:OpenCL verification}
\subsection{Drag}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/opencl_verification/drag_verification.png}
\caption{Normalized position and speed against time of a particle in a moving fluid.}
\label{fig:opencl_drag_verification}
\end{figure}
\subsection{Normal Collision}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/opencl_verification/normal_force_verification.png}
\caption{Normalized position and speed against time during a normal collision.}
\label{fig:opencl_normal_force_verification}
\end{figure}
\subsection{Friction Sliding}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/opencl_verification/friction_verification.png}
\caption{Normalized position and speed against time during a friction event.}
\label{fig:opencl_friction_verification}
\end{figure}
\subsection{Normal Collision with Cohesion}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.5]{figures/opencl_verification/cohesion_verification.png}
\caption{Normalized position and speed against time during a normal collision with cohesion.}
\label{fig:opencl_cohesion_verification}
\end{figure}
\section{Optimization and Performance}
\subsection{Optimizations}
\subsection{Performance}
Govender et al. have also developed GPU based DEM implementations and have provided performance measures in one of their papers\cite{performance}. The key performance measure they use is the Cundall Number. The Cundall Number is defined in Equation \ref{eq:cundall number} where $N$ is the number of particles and $FPS$ is the number of simulation frames that can be calculated in a second. The simulations performed in Govender et al.\cite{performance} were run on an NVIDIA Quadro K6000 GPU with an Intel i7 3.5 GHZ Extreme Edition CPU. The benchmarks for this project have been run on an NVIDIA Quadro P5000 GPU with an  Intel Xeon 3.5 GHz CPU.
\\To calculate the C Number of this project a 10 million particle simulation has been run with a timestep of 0.0005 seconds and a simulation length of 5 seconds. This simulation ran in 145.22 minutes yielding an $FPS$ of 1.148. This gives an overall C Number of $11.5 \times 10^6$.
\\The table in Figure \ref{fig:performance comparison} compares this project with Govender et al.\cite{performance}. It shows that Govender et al. have achieved significantly better performance. In addition, Govender et al. have improved their performance in a later paper\cite{blazedem}.
\\\\Although greater performance has been achieved in other codes, this project has achieved satisfactory performance. With further optimization, and implementation of more complex algorithms, it is conceivable that similar performance could be achieved.
\begin{equation}
C = N \times FPS
\label{eq:cundall number}
\end{equation}

\begin{figure}
\begin{center}
\begin{tabular}{|c c c c|}
\hline
Author & Shape & N Particles & C Number\\
\hline
This project & Sphere & $10 \times 10^6$ & $11.5 \times 10^6$ \\
Govender et al.\cite{performance} & Sphere & $50 \times 10^6$ & $55 \times 10^6$ \\
BLAZE-DEM\cite{blazedem} & Sphere & $32 \times 10^6$ & $100 \times 10^6$ \\
\hline
\end{tabular}
\end{center}
\caption{Performance comparison with another GPU DEM code.}
\label{fig:performance comparison}
\end{figure}
\subsection{Run time linearity}
One key objective of particle simulations with collisions is to reduce the simulation run time from $O(N^2)$ to $O(N)$. To assess this performance, simulations with increasing numbers of particles have been run. Notably, these simulations have logging to file disabled assess the algorithm performance only. Figure \ref{fig:opencl_performance} shows the results of these runs. The results show that the simulation is very close to being linear. At high numbers of particles the non-linearity is more evident, but still remains close to the extrapolated line.
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.7]{figures/opencl_performance.png}
\caption{Run time against number of particles for the OpenCL simulation compared to a linear extrapolation through $N=1e4$ and $N=1e6$.}
\label{fig:opencl_performance}
\end{figure}
\chapter{Application}
\label{ch:Application}
\textit{General overview of agglomerates and why different properties are interesting.}
\section{Simulation Setup}
\textit{Initial conditions, properties to be varied, how this is defined in the program.}
\subsection{Taylor-Green Vortex Flow}
Taylor-Green Vortex flow is a specific solution to the incompressible Navier-Stokes equations. Chow\cite{achow} simplifies these equations for cubic vortices with a control variable $A$ and vortex frequency $a$ as shown in Equations \ref{eq:tgv_u}, \ref{eq:tgv_v}, and \ref{eq:tgv_w}. This formulation has vortex boundaries at $-\pi$ and $\pi$. The flow is plotted in Figure \ref{fig:tgv_plot}.
\begin{align}
u &= A cos\Big(a\Big(x + \dfrac{\pi}{2a}\Big)\Big)sin\Big(a\Big(y + \dfrac{\pi}{2a}\Big)\Big)sin\Big(a\Big(z + \dfrac{\pi}{2a}\Big)\Big) \label{eq:tgv_u}\\
v &= A sin\Big(a\Big(x + \dfrac{\pi}{2a}\Big)\Big)cos\Big(a\Big(y + \dfrac{\pi}{2a}\Big)\Big)sin\Big(a\Big(z + \dfrac{\pi}{2a}\Big)\Big) \label{eq:tgv_v}\\
w &= -2A sin\Big(a\Big(x + \dfrac{\pi}{2a}\Big)\Big)sin\Big(a\Big(y + \dfrac{\pi}{2a}\Big)\Big)cos\Big(a\Big(z + \dfrac{\pi}{2a}\Big)\Big) \label{eq:tgv_w}
\end{align}
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.65]{figures/tgv_plot.png}
\caption{A z-y view of a Taylor-Green Vorted flow field. (Figure 5a from Chow\cite{achow}).}
\label{fig:tgv_plot}
\end{figure}
\subsection{Stokes Number}
The Stokes Number, Stk, describes how a particle moves through a fluid. A high Stokes Number indicates an inertial regime where a particle is relatively unaffected by the fluid. A low Stokes Number indicates a viscous flow regime where the particle closely follows the fluid. A Stokes Number around 1 is in a transitional regime between viscous and inertial. This is shown in Figure \ref{fig:stokes_number}. The Stokes Number for a particle in Stokes flow is defined as in Equation \ref{eq:stokes_number}\cite{achow}.
\\For the Taylor-Green Vortex flow used in these simulations, $l_0$ is the diameter of one of the vortices and $u_0$ is the average fluid flow speed $u_{f,avg}$. Chow\cite{achow} calculated that the average flow speed for Taylor-Green Vortex flow is $u_{f,avg} = 0.7839A$.
\begin{equation}
Stk = \dfrac{\rho_p d_p^2 u_0}{18 \mu l_0}
\label{eq:stokes_number}
\end{equation}
\begin{figure}[!htb]
\centering
\input{figures/stokes_number.tex}
\caption{Stokes Number regimes.}
\label{fig:stokes_number}
\end{figure}
\subsection{Stickiness Number}
The Stickiness Number, Sy, describes how likely particles are to stick to each other through collisions. $L_e$ is the effect length and is usually $d_e - d_b$, where $d_e$ is the effect diameter and $d_b$ is the body diameter. $k_c$ is the cohesion stiffness from equation \ref{eq:cohesion force}. $\epsilon$ is the coefficient of restitution, $u$ is the average particle speed, and $m$ is the average particle mass.

\begin{equation}
Sy = \dfrac{L_e \sqrt{k_c}}{\epsilon \sqrt{L_e^2 k_c + u^2 m}}
\end{equation}

This number is derived from the analytic solution for a normal cohesive collision $<$\textit{TODO: Add section for this in appendix or verification}$>$. When the effect length is $d_e - d_b$ and $u$ is the initial collision speed, the Stickiness Number determines whether the particles will stick after the collision.
\begin{align*}
Sy &< 1 \textit{ Does not stick}
\\ Sy & > 1 \textit{ Sticks}
\end{align*}
\section{Results}
\textit{Presentation of results, graphs etc.}
\section{Discussion}
\textit{Discussion of results including key relationships and conclusions.}
\chapter{Conclusion}
\textit{Overall conclusions from the project. This will likely include some discussion of the successes of the programs as well as a summary of the application results.}
\section{Further Work}
\subsection{Particle Rotation}
The DEM implementations in this project do not consider particle rotation. Future work could implement particle rotations to improve the simulation accuracy and give the simulation broader applicability. It is recommended that rotations be implemented using quaternions rather than Euler angles. Quaternions avoid problems such as gimbal lock and simplify rotation calculations.
\subsection{Polyhedral Particles}
This project only considers spherical particles, an implementation of polyhedral particles could give the simulation broader applicability. This would require particle rotation to be considered but would allow for analysis of more complex particle populations and more varied simulation parameters.
\subsection{Collision Detection Algorithms}
The spatial zoning algorithm in this project is simple but is not the most efficient algorithm available. Other algorithms, such as triangulation\cite{dynamictriangulations}, could be implemented to improve the efficiency of the simulation. More advanced algorithms could also simplify the implementation of better models, particularly friction models, that require collision history.
\subsection{Particle-Fluid Interaction}
This project assumes that the particle does not significantly affect the fluid, this vastly simplifies the simulation. However, particle interaction with the fluid could affect how the particles move and how groups of particles affect each other through the fluid. This would require a computational fluid dynamics code to be built into the simulation.
\appendix
\chapter{Derivations}
\label{ch:Derivations}
\section{Normal Collision}
\label{der:normal collision}
\begin{align*}
&m \ddot{x} = k_e \delta - \eta \dot{x} \\
&\delta = d_b - x \\
&m \ddot{x} = k_e d_b - k_e x - \eta \dot{x} \\
&m \ddot{x} + \eta \dot{x} + k_e x = d_b k_e \\\\
&\textbf{Complementary Function} \\
&\text{Auxilliary Equation: } mp^2 + \eta p + k_e = 0 \\
&p_{1,2} = \dfrac{- \eta \pm \sqrt{\eta^2 - 4 m k_e}}{2 m} \\
&\text{For this case $\eta ^ 2 > 4 m k_e$ so $p_1$ and $p_2$ are complex.} \\
&\text{Let: } a = \dfrac{-\eta}{2m} \text{ and } b = \dfrac{\sqrt{4mk_e - \eta ^ 2}}{2m} \\
&x = e^{at} (A_1 sin(bt) + A_2 cos(bt)) \\\\
&\textbf{Particular Integral} \\
&\text{Ansatz: } x = B \\
&\dot{x} = \ddot{x} = 0 \\
&k_e B = d_b k_e \\
&B = d_b \\
&x = d_b \\\\
&\textbf{General Solution} \\
&x = e^{at} (A_1 sin(bt) + A_2 cos(bt)) + d_b \\\\
&x(0) = d_b = A_2 + d_b \\
&A_2 = 0 \\\\
&\dot{x}(0) = u_0 = A_1 b \\
&A_1 = \dfrac{u_0}{b} \\\\
&x = e^{at} \dfrac{u_0}{b} sin(bt) + d_b \\
&\dot{x} = u_0 e^{at} (\dfrac{a}{b} sin(bt) + cos(bt))
\end{align*}
\subsection{Collision Duration}
\label{der:collision duration}
The duration of a collision is considered to be the time for which the particles' body surfaces are touching. For the normal collision used in section \ref{der:normal collision} this is from $t = 0$ until some $t_{col}$ when the moving particle returns to its starting position.
\begin{align*}
&\text{Let: } a = \dfrac{-\eta}{2m} \text{ and } b = \dfrac{\sqrt{4mk_e - \eta ^ 2}}{2m} \\
&x = e^{at} \dfrac{u_0}{b} sin(bt) + d_b \\
&\text{At $t = t_{col}$, $x = d_b$} \\
&e^{a t_{col}} \dfrac{u_0}{b} sin(b t_{col}) = 0 \\
&sin(bt_{col}) = 0 \\
&t_{col} = \dfrac{sin^{-1}(0)}{b} \\
&t_{col} = \dfrac{0 + n \pi}{b} = \dfrac{n \pi}{b} \text{ , } n \in \mathbb{Z} \\
&n = 0 \text{ Initial conditions.} \\
&n = 1 \text{ First crossing after collision, physical result for $t_{col}$.} \\
&t_{col} = \dfrac{\pi}{b} = \dfrac{2 \pi m}{\sqrt{4 m k_e - \eta ^ 2}} \\\\
&\text{This can be rearranged to use the coefficient of restitution:} \\
&t_{col} = \sqrt{\dfrac{m}{k_e}}\sqrt{\pi^2 + ln(\epsilon)^2}
\end{align*}
\subsection{Coefficient of Restitution}
\label{der:coefficient of restitution}
The coefficient of restitution, $\epsilon$, is the ratio of the speeds before ($u_0$) and after ($u_1$) the collision. Since the $x$ velocity after the collision is in the opposite direction to the $x$ velocity before the collision, $\epsilon = \dfrac{- u_1}{u_0}$. The velocity after the collision is determined by finding the velocity at $t = t_{col}$ where $t_{col}$ is the collision duration determined in section \ref{der:collision duration}.
\begin{align*}
&\text{From section \ref{der:normal collision}: } \dot{x} = u_0 e^{at} (\dfrac{a}{b} sin(bt) + cos(bt)) \\
&\text{From section \ref{der:collision duration}: } t_{col} = \dfrac{\pi}{b} \\
&u_1 = u_0 e^{at_{col}} (\dfrac{a}{b} sin(bt_{col}) + cos(bt_{col})) \\
&u_1 = u_0 e^{a \pi / b} (\dfrac{a}{b} sin(\pi) + cos(\pi)) \\
&u_1 = - u_0 e^{a \pi / b} \\
&\epsilon = \dfrac{- u_1}{u_0} = \dfrac{u_0 e^{a \pi / b}}{u_0} = e^{a \pi / b} \\\\
&\text{To determine the damping coefficient for a given $\epsilon$:} \\
&ln(\epsilon) = \dfrac{a \pi}{b} = \dfrac{- \eta \pi}{\sqrt{4 m k_e - \eta^2}} \\
&\eta^2 = \dfrac{4 m k_e ln(\epsilon)^2}{\pi^2 + ln(\epsilon)^2} \\
&\eta = \pm \sqrt{\dfrac{4 m k_e ln(\epsilon)^2}{\pi^2 + ln(\epsilon)^2}} \\
&\text{$\eta$ must be +ve, $ln(\epsilon)$ is -ve so we take the -ve square root.} \\
&\eta = - \sqrt{\dfrac{4 m k_e ln(\epsilon)^2}{\pi^2 + ln(\epsilon)^2}} 
 = - 2 ln(\epsilon) \sqrt{\dfrac{m k_e}{\pi^2 + ln(\epsilon)^2}} \\
&\text{This equation matches the one found in Tuley\cite{tuley}.}
\end{align*}
\section{Normal Collision with Cohesion}
\label{der:normal collision with cohesion}
A normal collision with cohesion has three regimes.
\begin{align*}
&m\dfrac{du}{dt} = 0 \text{ for } x > d_e \\
&m\dfrac{du}{dt} = - k_c \delta_e \text{ for } d_e > x > d_b \\
&m \dfrac{du}{dt} = m \ddot{x} = k_e \delta_b - \eta \dot{x} - k_c \delta_e \text{ for } x < d_b \\
\end{align*}
Two important definitions are those of body overlap ($\delta_b$) and effect overlap ($\delta_e$).
\begin{align*}
&\delta_b = d_b - x \\
&\delta_e = d_e - x \\
\end{align*}
\subsection{Cohesion Only, Incoming ($d_e > x > d_b, u < 0$)}
\begin{align*}
&m \ddot{x} = - k_c \delta_e = - k_c (d_e - x) \\
&m \ddot{x} - k_c x = - k_c d_e \\\\
&\textbf{Complementary Function} \\
&\text{Auxilliary Equation: } mp^2 - k_c = 0 \\
&p = \pm \sqrt{\dfrac{k_c}{m}} \\ 
&x = A_1 e^{t \sqrt{k_c / m}} + A_2 e^{- t \sqrt{k_c / m}} \\\\
&\textbf{Particular Integral} \\
&\text{Ansatz: } x = B \\
&\dot{x} = \ddot{x} = 0 \\
&- k_c x = - k_c d_e  \\
&- k_c B = - k_c d_e \\
& B = d_e \\\\
&\textbf{General Solution} \\
&x = A_1 e^{t \sqrt{k_c / m}} + A_2 e^{- t \sqrt{k_c / m}} + d_e \\
&\dot{x} = \sqrt{\dfrac{k_c}{m}} A_1 e^{t \sqrt{k_c / m}} - \sqrt{\dfrac{k_c}{m}} A_2 e^{- t \sqrt{k_c / m}} \\\\
&x(0) = d_e = A_1 + A_2 + d_e \\
&A_1 = - A_2 \\\\
&\dot{x}(0) = u_0 = \sqrt{\dfrac{k_c}{m}} A_1 - \sqrt{\dfrac{k_c}{m}} A_2 \\
&A_1 = \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} \\\\
&x = \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} e^{t \sqrt{k_c / m}} - \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} e^{- t \sqrt{k_c / m}} + d_e \\
&x = u_0 \sqrt{\dfrac{m}{k_c}} sinh\Big(t\sqrt{\dfrac{k_c}{m}}\Big) + d_e \\\\
&\dot{x} = \dfrac{u_0}{2} e^{t \sqrt{k_c / m}} + \dfrac{u_0}{2} e^{- t \sqrt{k_c / m}} \\
&\dot{x} = u_0 cosh\Big(t\sqrt{\dfrac{k_c}{m}}\Big)
\end{align*}
Two important results from this solution are the impact time ($t_i$) and impact velocity ($u_i$).
\subsubsection{Impact Time ($t_i$)}
\begin{align*}
&\text{At impact: } x = d_b \\
&d_b = \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} e^{t_i \sqrt{k_c / m}} - \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} e^{- t_i \sqrt{k_c / m}} + d_e \\
&\dfrac{2(d_b - d_e)}{u_0} \sqrt{\dfrac{k_c}{m}} = e^{t \sqrt{k_c / m}} - e^{-t \sqrt{k_c / m}}  = 2 sinh(\sqrt{\dfrac{k_c}{m}} t) \\
&t_i = \sqrt{\dfrac{m}{k_c}} sinh^{-1}\Bigg(\dfrac{d_b - d_e}{u_0} \sqrt{\dfrac{k_c}{m}}\Bigg)
\end{align*}
\subsubsection{Impact Velocity ($u_i$)}
\begin{align*}
&u_i = \dfrac{u_0}{2} e^{t_i \sqrt{k_c / m}} + \dfrac{u_0}{2} e^{- t_i \sqrt{k_c / m}} \\
&u_i = u_0 cosh\Big(t_i \sqrt{\dfrac{k_c}{m}}\Big) \\
\end{align*}
\subsection{Full Contact ($x < d_b$)}
\begin{align*}
&m \dfrac{du}{dt} = m \ddot{x} = k_e \delta_b - \eta \dot{x} - k_c \delta_e \\
&m\ddot{x} + \eta \dot{x} + (k_e - k_c) x = k_e d_b - k_c d_e \\\\
&\textbf{Complementary Function} \\
&\text{Auxilliary Equation: } mp^2 + \eta p + k_e - k_c = 0 \\
&p_{1,2} = \dfrac{- \eta \pm \sqrt{\eta^2 - 4m(k_e - k_c)}}{2 m} \\
&\text{For this case $k_e > k_c$ and $\eta ^ 2 > 4 m (k_e - k_c)$ so $p_1$ and $p_2$ are complex.} \\
&\text{Let: } a = \dfrac{-\eta}{2m} \text{ and } b = \dfrac{\sqrt{4mk_e - \eta ^ 2}}{2m} \\
&x = e^{at} (A_1 sin(bt) + A_2 cos (bt)) \\\\
&\textbf{Particular Integral} \\
&\text{Ansatz: } x = B \\
&\dot{x} = \ddot{x} = 0 \\
&(k_e - k_c)B = k_e d_b - k_c d_e \\
& B = \dfrac{k_e d_b - k_c d_e}{k_e - k_c} \\\\
&\textbf{General Solution} \\
&x = e^{at} (A_1 sin(bt) + A_2 cos (bt)) + \dfrac{k_e d_b - k_c d_e}{k_e - k_c} \\
&\dot{x} = e^{at}((A_1 a - A_2 b)sin(bt) + (A_1 b + A_2 a) cos(bt)) \\\\
&\text{To simplify the result the $t$ here is $t - t_i$ in the overall collision.} \\
&x(0) = d_b \\
&A_2 + \dfrac{k_e d_b - k_c d_e}{k_e - k_c} = d_b \\
&A_2 = \dfrac{k_c (d_e - d_b)}{k_e - k_c} \\\\
&\text{Let: } c = \dfrac{k_c (d_e - d_b)}{k_e - k_c} \\\\
&\dot{x}(0) = aA_2 + bA_1 = u_i \\
&A_1 = \dfrac{u_i - aA_2}{b} = \dfrac{u_i - ac}{b} \\\\
&x = e^{at} (\dfrac{u_i - ac}{b} sin(bt) + c cos (bt)) + \dfrac{k_e d_b - k_c d_e}{k_e - k_c} \\
&\dot{x} = e^{at}\Big(\Big(\dfrac{u_i - ac}{b} a - c b\Big)sin(bt) + u_i cos(bt)\Big) \\\\
\end{align*}
The position cannot be analytically solved for $t$ in order to find the initial return velocity. A reasonable estimation for this is to use $t_{col} = \dfrac{\pi}{b}$, and other results, from section \ref{der:normal collision}. Thus the initial return velocity, $u_r$, can be found to be $u_r = - \epsilon u_i$.
\subsection{Cohesion Only, Returning ($d_e > x > d_b, u > 0$)}
The General Solution to the returning equation is the same as the incoming equation.
\begin{align*}
&\textbf{General Solution} \\
&x = A_1 e^{t \sqrt{k_c / m}} + A_2 e^{- t \sqrt{k_c / m}} + d_e \\
&\dot{x} = \sqrt{\dfrac{k_c}{m}} A_1 e^{t \sqrt{k_c / m}} - \sqrt{\dfrac{k_c}{m}} A_2 e^{- t \sqrt{k_c / m}} \\\\
&\text{To simplify the result the $t$ here is $t - t_r$ in the overall collision where $t_r$ is the return time.} \\
&x(0) = d_b = A_1 + A_2 + d_e \\
&A_1 + A_2 = (d_b - d_e)\\\\
&\dot{x}(0) = u_r = \sqrt{\dfrac{k_c}{m}} A_1 - \sqrt{\dfrac{k_c}{m}} A_2 \\
&A_1 = \dfrac{1}{2}\Big(d_b - d_e + u_r \sqrt{\dfrac{m}{k_c}} \Big) \\
&A_2 = \dfrac{1}{2}\Big(d_b - d_e - u_r \sqrt{\dfrac{m}{k_c}} \Big) \\
&A_1 = \dfrac{u_0}{2} \sqrt{\dfrac{m}{k_c}} \\\\
&x = (d_b - d_e)cosh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r \sqrt{\dfrac{m}{k_c}} sinh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) + d_e \\
&\dot{x} = \sqrt{\dfrac{k_c}{m}}(d_b - d_e)sinh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r cosh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) \\
\end{align*}
\section{Stickiness Number}
Taking the results from section \ref{der:normal collision with cohesion} it is known that if the particle is to escape the collision the position, $x$, will at some point return to $d_e$. Thus:
\begin{align*}
&d_e = (d_b - d_e)cosh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r \sqrt{\dfrac{m}{k_c}} sinh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) + d_e \\
&(d_b - d_e)cosh\Big(\sqrt{\dfrac{k_c}{m}} t\Big) + u_r \sqrt{\dfrac{m}{k_c}} sinh\Big(\sqrt{\dfrac{k_c}{m}}t\Big) = 0 \\
&tanh(\sqrt{\dfrac{k_c}{m}} t) = \dfrac{d_e - d_b}{u_r \sqrt{\dfrac{m}{k_c}}} \\
&\text{This only has a solution when the RHS is less than 1.} \\
&\text{Thus, for a particle to stick in a collision:} \\
&\dfrac{d_e - d_b}{u_r}\sqrt{\dfrac{k_c}{m}} > 1 \\
&u_r = -\epsilon u_i \\
&u_i = u_0 cosh\Big(t_i \sqrt{\dfrac{k_c}{m}}\Big) = u_0 cosh\Big(sinh^{-1}\Big(\dfrac{d_b - d_e}{u_0}\sqrt{\dfrac{k_c}{m}}\Big)\Big) \\
&\dfrac{d_e - d_b}{u_r}\sqrt{\dfrac{k_c}{m}} = \dfrac{d_e - d_b}{-\epsilon u_0 cosh\Big(sinh^{-1}\Big(\dfrac{d_b - d_e}{u_0}\sqrt{\dfrac{k_c}{m}}\Big)\Big)}\sqrt{\dfrac{k_c}{m}} \\
&\dfrac{d_e - d_b}{u_r}\sqrt{\dfrac{k_c}{m}} = \dfrac{(d_b - d_e)\sqrt{k_c}}{\epsilon \sqrt{(d_b - d_e)^2 k_c + u_0 ^ 2 m}} \\\\
&\text{Finding the dimensions of this number:} \\
&\text{Dimensions of stiffness: } [M][L][T]^{-2}[L]^{-1} = [M][T]^{-2} \\
&\dfrac{[L]([M][T]^{-2})^{0.5}}{[1]([L]^2[M][T]^{-2} + [L]^2[T]^{-2}[M])^{0.5}} \\
& = \dfrac{[L][M]^{0.5}[T]^{-1}}{[L][T]^{-1}[M]^{0.5}} = [1] \\
&\text{This shows that the number is dimensionless.}
\end{align*}
\section{Dynamic Friction Sliding}
\begin{align*}
&F_n = mg \\
&F_t^{dynamic} = - \mu |F_n| \\
&\dfrac{du}{dt} = \ddot{x} = \dfrac{- \mu m g}{m} = - \mu g\\
&\dot{x} = - \mu g t + u_0 \\
&x = \dfrac{- \mu g}{2}t^2 + u_0 t + x_0 \\
\end{align*}
\section{Particle Drag}
\label{der:drag}
\begin{align*}
&m\dfrac{du}{dt} = \dfrac{m}{\tau}(u_f - u) \\
&\ddot{x} + \dfrac{1}{\tau} \dot{x} = \dfrac{u_f}{\tau} \\\\
&\textbf{Complementary Function} \\
&\text{Auxilliary Equation: } p^2 + \dfrac{1}{\tau}p = 0 \\
&p_1 = 0, p_2 = - \dfrac{1}{\tau} \\
&x = A_1e^{0t} + A_2e^{-t/\tau} \\\\
&\textbf{Particular Integral} \\
&\text{Ansatz: } x = Bt \\
&\dot{x} = B \\
&\ddot{x} = 0 \\
&\dfrac{B}{\tau} = \dfrac{u_f}{\tau} \\
&B = u_f \\\\
&\textbf{General Solution} \\
&x = A_1 + A_2 e^{-t /\tau} + u_f t \\
&\dot{x} = \dfrac{-A_2}{\tau} e^{-t/\tau} + u_f \\\\
&x(0) = 0 = A_1 + A_2 \\
&\dot{x}(0) = 0 = \dfrac{-A_2}{\tau} + u_f \\
&A_2 = u_f \tau \\
&A_1 = - u_f \tau \\\\
&x = u_f \tau (e^{-t/\tau} - 1) + u_f t \\
&\dot{x} = u_f (1 - e^{-t/\tau}) \\
\end{align*}
\bibliography{references}
\bibliographystyle{unsrt}
\end{document}
